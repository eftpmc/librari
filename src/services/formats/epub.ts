import fs from 'fs';
import path from 'path';
import axios from 'axios';

var nodepub = require('nodepub');
import JSZip from "jszip";
import sanitizeHtml from 'sanitize-html';

async function VERCEL_fetchImageAndSaveToTemp(url: string): Promise<string> {
    const response = await axios.get(url, { responseType: 'arraybuffer' });
    const buffer = Buffer.from(response.data, 'binary');
    const filePath = `/tmp/${Date.now()}.jpeg`;
    await fs.promises.writeFile(filePath, buffer);
    return filePath;
}

async function LOCAL_fetchImageAndSaveToTemp(url: string): Promise<string> {
    const response = await axios.get(url, {
        responseType: 'arraybuffer'
    });

    if (response.status !== 200) {
        throw new Error(`Failed to fetch image from ${url}. Status: ${response.status}`);
    }

    const buffer = Buffer.from(response.data);

    const tempDir = path.join(__dirname, 'temp');
    await fs.promises.mkdir(tempDir, { recursive: true });
    const tempFileName = path.join(tempDir, `${Date.now()}.jpeg`);

    await fs.promises.writeFile(tempFileName, buffer);

    return tempFileName;
}

function sanitizeBookContent(htmlContent: string): string {
    const allowedTags = ['div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'span', 'a', 'img', 'ul', 'ol', 'li', 'em', 'strong', 'br', 'blockquote']; // ... any other tags you want to allow
    const allowedAttributes = {
        'a': ['href'],
        'img': ['src', 'alt'], // ... any other attributes you want to allow for specific tags
    };

    const cleanedContent = sanitizeHtml(htmlContent, {
        allowedTags: allowedTags,
        allowedAttributes: allowedAttributes,
        selfClosing: ['br', 'img'], // self-close tags like <br/> and <img/>
        parser: {
            lowerCaseTags: true,  // convert tags to lowercase
        }
    });

    return cleanedContent;
}

async function createEpub(files: any[]): Promise<Buffer> {
    const zip = new JSZip();

    // Sort files so that the mimetype is first and uncompressed
    const sortedFiles = files.sort((a, b) => a.name === "mimetype" ? -1 : 1);

    for (const file of sortedFiles) {
        zip.file(`${file.folder ? file.folder + '/' : ''}${file.name}`, file.content, { compression: file.compress ? "DEFLATE" : "STORE" });
    }

    const epubContent = await zip.generateAsync({ type: "nodebuffer", mimeType: "application/epub+zip" });
    return epubContent;
}

export async function createEpubBuffer(title: string, coverImage: string, chapters: string[]): Promise<Buffer> {
    const coverImagePath = await LOCAL_fetchImageAndSaveToTemp(coverImage);

    const metadata = {
        id: Date.now().toString(),
        title: title,
        author: 'Ari',
        fileAs: 'Ari',
        genre: 'Fantasy', // Adjust as needed
        tags: 'Ari,Generated,EPUB', // Adjust as needed
        cover: coverImagePath,
        contents: 'Table of Contents'
    };

    var epub = nodepub.document(metadata);

    epub.addSection("Introduction",
        `<h1>Introduction</h1>
    <p>This book was programmatically generated by Ari. The content you will read in the following chapters has been scraped from various online sources and compiled into an EPUB format for easier reading and accessibility.</p>
    <p>The idea behind this automation is to make a wide array of information readily available in a format that can be conveniently consumed. Each chapter in this book corresponds to different web pages or articles from the source URL provided.</p>
    <p>We hope you find this compilation informative and enjoyable!</p>`,
        false, true);

    for (let i = 0; i < chapters.length; i++) {
        let chapterContent = chapters[i];
        const sanitizedContent = sanitizeBookContent(chapterContent);
        epub.addSection(`Chapter ${i + 1}`, `<h1>Chapter ${i + 1}</h1>` + sanitizedContent);
    }

    const files = await epub.getFilesForEPUB();
    await fs.promises.unlink(coverImagePath);

    return await createEpub(files);
}