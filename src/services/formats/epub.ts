import fs from 'fs';
import path from 'path';
import axios from 'axios';
import nodepub from 'nodepub';
import JSZip from "jszip";
import sanitizeHtml from 'sanitize-html';

// Constants
const TEMP_DIR = path.join(__dirname, 'temp');
const ALLOWED_TAGS = ['div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'span', 'a', 'img', 'ul', 'ol', 'li', 'em', 'strong', 'br', 'blockquote'];
const ALLOWED_ATTRIBUTES = {
    'a': ['href'],
    'img': ['src', 'alt'],
};

async function fetchImageAndSaveToTemp(url: string, local: boolean = false): Promise<string> {
    const response = await axios.get(url, { responseType: 'arraybuffer' });

    if (response.status !== 200) {
        throw new Error(`Failed to fetch image from ${url}. Status: ${response.status}`);
    }

    const buffer = Buffer.from(response.data);
    const filePath = local
        ? path.join(TEMP_DIR, `${Date.now()}.jpeg`)
        : `/tmp/${Date.now()}.jpeg`;

    if (local) {
        await fs.promises.mkdir(TEMP_DIR, { recursive: true });
    }

    await fs.promises.writeFile(filePath, buffer);
    return filePath;
}

function sanitizeBookContent(htmlContent: string): string {
    return sanitizeHtml(htmlContent, {
        allowedTags: ALLOWED_TAGS,
        allowedAttributes: ALLOWED_ATTRIBUTES,
        selfClosing: ['br', 'img'],
        parser: {
            lowerCaseTags: true,
        }
    });
}

async function createEpub(files: any): Promise<Buffer> {
    const zip = new JSZip();
    const sortedFiles = files.sort((a: { name: string; }, b: any) => a.name === "mimetype" ? -1 : 1);

    for (const file of sortedFiles) {
        zip.file(`${file.folder ? file.folder + '/' : ''}${file.name}`, file.content, { compression: file.compress ? "DEFLATE" : "STORE" });
    }

    return zip.generateAsync({ type: "nodebuffer", mimeType: "application/epub+zip" });
}

export async function createEpubBuffer(title: string, coverImage: string, chapters: string[]): Promise<Buffer> {
    const coverImagePath = await fetchImageAndSaveToTemp(coverImage, false);

    const metadata: nodepub.Metadata = {
        id: Date.now().toString(),
        title,
        author: 'Ari',
        fileAs: 'Ari',
        genre: 'Fantasy',
        tags: 'Ari,Generated,EPUB',
        cover: coverImagePath,
        contents: 'Table of Contents'
    };

    const epub = nodepub.document(metadata);
    epub.addSection("Introduction", `
    <h1>Introduction</h1>
    <p>This book was programmatically generated by Ari. The content you will read in the following chapters has been scraped from various online sources and compiled into an EPUB format for easier reading and accessibility.</p>
    <p>The idea behind this automation is to make a wide array of information readily available in a format that can be conveniently consumed. Each chapter in this book corresponds to different web pages or articles from the source URL provided.</p>
    <p>We hope you find this compilation informative and enjoyable!</p>`, false);
    chapters.forEach((chapterContent, i) => {
        const sanitizedContent = sanitizeBookContent(chapterContent);
        epub.addSection(`Chapter ${i + 1}`, `<h1>Chapter ${i + 1}</h1>${sanitizedContent}`);
    });

    const files = await epub.getFilesForEPUB();
    await fs.promises.unlink(coverImagePath);

    return createEpub(files);
}
